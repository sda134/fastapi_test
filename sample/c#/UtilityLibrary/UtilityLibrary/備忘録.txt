
--- Timerに関して --------------------------------------

System.Windows.Forms.Timer 
	OnTick イベントで処理を行う。
	同期なので、コントロールにもアクセスできる。

System.Windows.Threading.DispatcherTimer　???
	同期なので、コントロールにもアクセスできる。

System.Threading.Timer
	•unsafe
	•軽量
	•一回作成すると設定したタイマーイベントの内容が変更できない

System.Timers.Timer
	•unsafe
	•サーバベース・タイマと呼ばれ、高精度
	ただし、16ms以下のインターバルはOSの制約から指定しても意味がないらしく、実際にはほぼ同等らしい

System.Diagnostics.Stopwatch stopwatch
	ただ時間を測るだけ
	Reset	: Stop 状態にして時間を戻す。再度Start する必要がある。
	Restart : Run の状態のまま時間だけ戻す。


--- Task 関連 --------------------------------------


// 非同期処理の開始
Task.Run(async () =>
{
	Console.WriteLine("スレッドID:{0}", System.Threading.Thread.CurrentThread.ManagedThreadId);
}

// async時のSleepは System.Threading.Tasks.Task.Delay(3000); がいいとか


// 同期処理
bool ret = task.Result;

// 非同期処理　※但しasync メソッドでしか実行できない
bool ret = await task.Result;

※async void　を使うと：　
・処理終了のコールバックを受けられない
・例外処理ができない（？）
→ EventHandler で良い


--- linq 関連 --------------------------------------

 orderby clm.Index descending  // descending = 降順

※拡張メソッド OrderBy の注意点！インスタンス内のメンバを並び替えるのではなく、
並び替えた IEnumerable<T> を返す仕様。

×　items.OrderBy(x => x.Index);
○　var orderedItems = items.OrderBy(x => x.Index);

--- Enum 関連 --------------------------------------

// Enum をループしつつ List に変換する方法
var conditionTypeList = new List<ConditionType>(Enum.GetValues(typeof(ConditionType)).Cast<ConditionType>().ToList());


// Combobox に Enum を直接割り当てる方法  CompareType というEnum の場合
this.combobox1.DataSource =  Enum.GetValues(typeof(CompareType))

値を代入する時は SelectedItem プロパティでないとエラーが起こる： e.g. SelectedItem = CompareType.Atype;
取得するときは SelectedItem でも SelectedValue でも大丈夫らしい。


--- Flag 関連 --------------------------------------

Flag f = Flag.A | Flag.B; 	加算

if((f & Flags.A) != 0)
((f & Flags.A) == Flags.A);
f.HasFlag(Flags.A);

どれも同じ？


--- Byte/Bit 関連 --------------------------------------

bit 配列、つまり bool の配列の作成方法

var bitArray  = new System.Collections.BitArray(someObject);
                
bitArray.CopyTo(arg);


& 論理積 

| 論理和 	単純な加算 e.g. 0x01 | 0x10 = 0x11 = 17(dec)

^ 排他的論理和 

~ 反転 




--- Generic 関連 --------------------------------------

//ジェネリックのインスタンス生成方法						
//this.instance = (T)Activator.CreateInstance(typeof(T));


--- Reflection 関連 ----------------------------------
            
// 指定クラスのTypeオブジェクトを取得する
Type t = typeof(TestClass);

            
// インスタンスの生成
object instance = t.InvokeMember(null, System.Reflection.BindingFlags.CreateInstance,
                null,
                null,
                new object[] { });

// フィールドの取得　※見つからなかった場合は null が返ってくる
System.Reflection.FieldInfo fd = t.GetField("FieldMember");

// プロパティの取得　※プロパティを GetField で取得できない → null が返ってくる            
System.Reflection.PropertyInfo pi = t.GetProperty("PropertyMember");


// メンバやプロパティ名（string)  を取得する 
Type t = typeof(MachineFormat);

                    //プロパティを取得する
                    var members = t.GetProperties(
                        System.Reflection.BindingFlags.Public |
                        System.Reflection.BindingFlags.Instance |
                        System.Reflection.BindingFlags.DeclaredOnly);

foreach (System.Reflection.PropertyInfo m in members)                    
{
                        //メンバの型と、名前を表示する
                        Console.WriteLine("{0} - {1}", m.MemberType, m.Name);
}


// 値の取得と代入
                        var pi = t.GetProperty("PublicProperty");
                        pi.SetValue(target, 1, null);
                        int num = (int)pi.GetValue(target, null);


--- System.Drawing 関連 -------------------------------------------

// システムカラー
System.Drawing.SystemColors


// フォントの変更方法
this.textBox1.Font = new Font("MS UI Gothic", 9.0f, FontStyle.Regular);



--- 条件分岐 関連 -------------------------------------------

・型スイッチ
	object obj = "abc";

	switch (obj)
	{
		case string obj_str: // 新しい変数として利用
			Console.WriteLine(obj_str);
			break;

		default:
			break;
	}

--- .NET バージョン対応 -------------------------------------------

.NET のバージョンごとのシンボル定義の仕方

プロジェクトファイル( .csproj )に以下を追加

e.g.

// 一つずつ書くタイプ
  <PropertyGroup Condition=" '$(TargetFrameworkVersion)' == 'v3.5' ">
    <DefineConstants>NET10;NET20;NET30;NET35;$(DefineConstants)</DefineConstants>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(TargetFrameworkVersion)' == 'v4.0' ">
    <DefineConstants>NET10;NET20;NET30;NET35;NET40;$(DefineConstants)</DefineConstants>
  </PropertyGroup>

// 一気に書くタイプ
  <PropertyGroup>
    <DefineConstants Condition=" $(TargetFrameworkVersion.Replace('v', '')) &gt;= 2.0 ">$(DefineConstants)NET10;NET20;$(DefineConstants)</DefineConstants>
    <DefineConstants Condition=" $(TargetFrameworkVersion.Replace('v', '')) &gt;= 3.5 ">$(DefineConstants)NET10;NET20;NET30;NET35;$(DefineConstants)</DefineConstants>
    <DefineConstants Condition=" $(TargetFrameworkVersion.Replace('v', '')) &gt;= 4.0 ">$(DefineConstants)NET10;NET20;NET30;NET35;NET40;$(DefineConstants)</DefineConstants>
    <DefineConstants Condition=" $(TargetFrameworkVersion.Replace('v', '')) &gt;= 4.5 ">$(DefineConstants)NET10;NET20;NET30;NET35;NET40;NET45;$(DefineConstants)</DefineConstants>
    <DefineConstants Condition=" $(TargetFrameworkVersion.Replace('v', '')) &gt;= 4.6 ">$(DefineConstants)NET10;NET20;NET30;NET35;NET40;NET45;NET46;$(DefineConstants)</DefineConstants>
    <DefineConstants Condition=" $(TargetFrameworkVersion.Replace('v', '')) &gt;= 4.7 ">$(DefineConstants)NET10;NET20;NET30;NET35;NET40;NET45;NET46;NET47;$(DefineConstants)</DefineConstants>
  </PropertyGroup>


情報元
https://code.i-harness.com/ja/q/2c9aca

+α バージョン対応表
https://qiita.com/nskydiving/items/3af8bab5a0a63ccb9893



--- コマンドライン -------------------------------------------

 // https://dobon.net/vb/dotnet/process/standardoutput.html

            // インスタンス生成
            using (var p = new System.Diagnostics.Process())
            {
                //ComSpec(cmd.exe)のパスを取得して、FileNameプロパティに指定
                p.StartInfo.FileName = System.Environment.GetEnvironmentVariable("ComSpec");
                //出力を読み取れるようにする
                p.StartInfo.UseShellExecute = false;
                p.StartInfo.RedirectStandardOutput = true;
                p.StartInfo.RedirectStandardInput = false;
                
                //ウィンドウを表示しないようにする
                //p.StartInfo.CreateNoWindow = true;
                
                //コマンドラインを指定（"/c"は実行後閉じるために必要）
                p.StartInfo.Arguments = @"/c dir c:\ /w";

                //起動
                p.Start();

                //出力を読み取る
                string results = p.StandardOutput.ReadToEnd();

                //プロセス終了まで待機する
                //WaitForExitはReadToEndの後である必要がある
                //(親プロセス、子プロセスでブロック防止のため)
                p.WaitForExit();
                p.Close();
	}



--- その他 -------------------------------------------


// パラメータ付きのコンストラクタの継承の仕方
public NewClass(int arg)
            : base(arg)
        {

        }



// config で自作クラスを保存する方法
[global::System.Configuration.UserScopedSettingAttribute()]
public System.Collections.Generic.List<string> Lines
{
    get
    {
        return ((System.Collections.Generic.List<string>)(this["Lines"]));
    }
    set
    {
        this["Lines"] = value;
    }
}


マルチスレッド処理に関するプロパティは foreach を避けた方が良い。






UserControl を継承したクラスで、デザイナを用いた際に自動生成される InitializeComponent に注意！
すべての public property を初期値で生成するコードが自動で書かれる。
その為、例えば private List<T> _item = new List<T> のようにフィールドでインスタンス生成したメンバがあっても、
その _item にアクセスする public property があると、InitializeComponent で初期値が入ってしまい null が代入される





JSon シリアライザー　というのもあるとか
Xml や Json では対応できないクラスも存在する為、その場合以下のような方法をとる

         [XmlIgnore]
         public Font UIFont { get; set; }

         [DataMember]
         public string UIFontText
         {
             get { return ConvertToString(UIFont); }
             set
             {
                 var f = ConvertFromString<Font>(value);
                 if (f != null) { UIFont = f; }
             }
         }


SettingBase の制作について：static class 内に instance class を含む方法

